//idk tbh had chatgpt generate this based on my python code HAS NOT BEEN DOUBLE CHECKED YET SIMON WILL DO BEFORE FRIDAY

#include <Arduino.h>
#include <Wire.h>
#include <HMC5883L.h>

// Define motor control pins
const int motorLeftForward = 5;
const int motorLeftBackward = 18;
const int motorRightForward = 19;
const int motorRightBackward = 21;
HMC5883L compass; //change this depending on compass

#define TURN_THRESHOLD 2.0 // Threshold for heading accuracy in degrees

// Initialize variables
String inputString = "";

void setup() {
  Serial.begin(9600);
  // Initialize motor control pins as outputs
  pinMode(motorLeftForward, OUTPUT);
  pinMode(motorLeftBackward, OUTPUT);
  pinMode(motorRightForward, OUTPUT);
  pinMode(motorRightBackward, OUTPUT);

  // Initialize I2C communication
  Wire.begin();

  // Initialize compass
  compass.initialize();

  // Check if compass is connected
  if (!compass.testConnection()) {
    Serial.println("Compass connection failed!");
    while (1);
  }

  Serial.println("Compass initialized successfully.");
}

void loop() {
  // Read input from serial
  if (Serial.available()) {
    char inChar = (char)Serial.read();
    if (inChar == '\n') {
      parseCommand(inputString);
      inputString = "";
    } else {
      inputString += inChar;
    }
  }
}

void parseCommand(String cmd) {
  cmd.trim();  // Remove any leading/trailing whitespace
  if (cmd.startsWith("FORWARD")) {
    float distance = cmd.substring(8).toFloat();
    moveForward(distance);
  } else if (cmd.startsWith("TURN")) {
    float angle = cmd.substring(5).toFloat();
    turnAngle(angle);
  } else if (cmd == "STOP") {
    stopMovement();
  }
}

void moveForward(float distance) {
  // Convert distance to motor run time (adjust based on your robot's calibration)
  int runTime = distanceToTime(distance);
  // Move forward
  digitalWrite(motorLeftForward, HIGH);
  digitalWrite(motorRightForward, HIGH);
  delay(runTime);
  stopMovement();
}

void turnAngle(float angle) {
  float currentHeading = getCurrentHeading();
  float targetHeading = currentHeading + angle;

  // Normalize targetHeading to [0, 360)
  if (targetHeading >= 360.0) {
    targetHeading -= 360.0;
  } else if (targetHeading < 0.0) {
    targetHeading += 360.0;
  }

  if (angle > 0) {
    // Turn right
    digitalWrite(motorLeftForward, HIGH);
    digitalWrite(motorRightBackward, HIGH);
  } else {
    // Turn left
    digitalWrite(motorLeftBackward, HIGH);
    digitalWrite(motorRightForward, HIGH);
  }

  while (true) {
    float currentHeading = getCurrentHeading();
    float headingDifference = targetHeading - currentHeading;

    // Normalize headingDifference to [-180, 180]
    if (headingDifference > 180.0) {
      headingDifference -= 360.0;
    } else if (headingDifference < -180.0) {
      headingDifference += 360.0;
    }

    if (abs(headingDifference) <= TURN_THRESHOLD) {
      break;
    }
    delay(50);  // Small delay to prevent I2C bus overload
  }

  stopMovement();
}

void stopMovement() {
  // Stop all motors
  digitalWrite(motorLeftForward, LOW);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, LOW);
  digitalWrite(motorRightBackward, LOW);
}

int distanceToTime(float distance) {
  // Placeholder conversion (needs calibration)
  // e.g., 1 meter = 1000 milliseconds
  return (int)(distance * 1000.0);
}

float getCurrentHeading() {
  Vector norm = compass.readNormalize();

  // Calculate heading in degrees
  float heading = atan2(norm.YAxis, norm.XAxis);
  if (heading < 0) {
    heading += 2 * PI;
  }
  float headingDegrees = heading * 180 / M_PI;

  return headingDegrees;
}
